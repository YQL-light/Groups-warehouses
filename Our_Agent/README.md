# WeaTrip天气助手智能体实现文档

----

## MCP_SERVER实现说明文档

### 一、概述

本项目开源文件中的MCP_SERVER是一个基于 **MCP（Model Context Protocol）** 框架的服务端，作为天气信息工具模块的提供者，用于响应来自智能体客户端（如 MCP Client）的调用请求。

简单来说，这个服务端扮演了一个“数据提供者”的角色：

- 一方面，它通过 **OpenWeatherMap API** 获取实时天气与未来预报数据；
- 另一方面，它通过 **MCP 协议** 将这些功能以标准化的工具形式暴露给客户端；
- 当大语言模型调用相关工具时，服务端会处理请求、访问外部天气数据源、格式化结果并返回标准化响应。

通过该服务端，模型能够自动获取天气信息、生成播报模板，并输出自然语言化的天气报告。

------

### 二、服务器端结构设计

整个服务器端系统主要由以下几个核心模块组成：

| 模块名称                        | 主要功能                                                     |
| ------------------------------- | ------------------------------------------------------------ |
| **FastMCP 服务实例**            | 定义并运行一个名为“weather”的 MCP 服务端，负责注册所有天气工具和提示模板。 |
| **OpenWeatherMap 接口封装**     | 实现与外部天气 API 的通信，包括异步请求与响应解析。          |
| **数据格式化模块**              | 将 JSON 天气数据转换为可读文本格式，便于模型理解和展示。     |
| **MCP 工具函数（@mcp.tool）**   | 提供可被模型直接调用的功能接口，如获取当前天气、获取五日天气预报等。 |
| **提示模板模块（@mcp.prompt）** | 定义天气报告生成模板，引导模型输出自然语言播报内容。         |
| **综合报告生成器**              | 结合工具数据与模板，返回结构化的报告输入，供模型自动生成天气说明。 |

系统整体运行逻辑如下：

<center>用户或大模型发出天气查询请求<center>
                           ↓
<center> MCP Client 调用天气工具（如 `get_weather` 或 `weather_report`）<center>
                           ↓
<center> MCP Server 接收请求，访问 OpenWeatherMap API<center>
                           ↓
<center> 解析、格式化数据并生成结果<center>
                           ↓
<center> 将结果返回客户端或交由模型进一步生成自然语言报告<center>


----

### 三、主要功能流程

#### 1. 服务初始化与注册

在程序启动时，首先通过以下代码创建一个 MCP 服务实例：

```python
mcp = FastMCP("weather")
```

`FastMCP` 是 MCP 框架提供的快速服务端构建类，这里实例化的 `"weather"` 即为当前服务名称。所有后续定义的工具和提示模板都将自动注册到该服务实例下。服务端通过标准输入输出（`stdio`）与客户端进行通信，从而确保跨语言、跨进程的兼容性。

#### 2. API 配置与请求封装

程序中定义了与 OpenWeatherMap 的通信参数：

```python
OPENWEATHER_API_BASE = "https://api.openweathermap.org/data/2.5"
OPENWEATHER_API_KEY = "your_api_key"
USER_AGENT = "weather-app/1.0"
```

同时实现了核心请求函数 `make_weather_request(url)`，用于发送异步 HTTP 请求。该函数内部使用 `httpx.AsyncClient` 建立会话，设置请求头并在 30 秒超时范围内完成调用。若 API 响应成功则返回解析后的 JSON 数据，否则打印错误并返回 `None`，从而保证系统的健壮性。

#### 3. 数据格式化逻辑

API 返回的数据为原始 JSON 格式，不便于直接展示。
 函数 `format_weather_data(data, units)` 负责将这些数据转换为可读的多行文本输出，提取并格式化城市名、国家代码、天气描述、温度、湿度、风速等核心信息。该函数还会根据单位制（`metric` 或 `imperial`）自动切换温度（°C/°F）和风速（m/s/mph）单位。最终生成的结果简洁明了，既适合人类阅读，也便于模型进行语义提取。

#### 4. 工具函数注册与调用

本项目定义了三个主要 MCP 工具：

1. **`get_weather()`**：获取指定城市的实时天气信息；
2. **`get_forecast()`**：获取未来五天（以三小时为间隔）的天气预报数据；
3. **`weather_report()`**：结合天气信息与提示模板，生成结构化报告输入。

这些函数均通过装饰器 `@mcp.tool()` 注册为 MCP 工具，供客户端调用。
 以 `get_weather()` 为例，当接收到城市名称参数后，函数会拼接完整的 API 请求地址，调用 `make_weather_request()` 获取数据，再通过 `format_weather_data()` 输出格式化结果。如果 API 响应中包含错误代码，则会在返回信息中提示具体错误原因。

`get_forecast()` 的工作机制与之类似，只是针对五日预报接口进行数据提取与批量格式化输出，方便模型了解天气趋势。

#### 5. 天气报告提示模板

  除了工具函数外，程序还定义了一个提示模板函数 `weather_prompt()`，通过 `@mcp.prompt()` 装饰器注册。
  该模板用于指导大语言模型如何根据结构化天气数据生成自然语言报告。模板中要求模型输出内容包含“今日天气概况”、“体感与舒适度分析”、“穿衣建议”及“户外活动推荐”等四个部分，并强调语言应自然、贴近生活，而非技术化描述。
  这种模板化提示机制使得模型生成的天气播报内容更加规范、统一且富有可读性。

#### 6. 综合报告生成与模板绑定

`weather_report()` 是系统的综合性工具函数，它结合了前述两个模块的功能。
 当客户端或模型调用该函数时，系统首先执行 `get_weather()` 获取实时天气文本，然后通过正则表达式从文本中解析出关键字段（如温度、湿度、风速等），构建一个包含必要参数的字典结构。
 最终返回结果为一个包含三部分内容的 JSON 对象：

- `raw_data`：原始天气文本；
- `prompt_template`：对应模板名称（如 `weather_prompt`）；
- `template_args`：模板参数（城市、天气描述、温度、湿度等）。

大模型在接收此结果后，会根据模板名找到相应的提示模板函数，并将 `template_args` 中的内容填入模板文本中，自动生成自然语言播报报告。这种设计实现了“数据 → 模板 → 语言”的闭环处理逻辑。

#### 7. 服务运行与通信机制

程序的入口部分定义如下：

```python
if __name__ == "__main__":
    mcp.run(transport='stdio')
```

这段代码负责启动 MCP Server 并启用标准输入输出通信通道。
 当客户端启动并指定该服务端脚本路径时，双方会通过 stdin/stdout 建立通信，服务端开始监听来自客户端的工具调用请求，处理后返回结果。整个过程异步执行，保证了高效与实时性。

------

### 四、运行流程总结

MCP Server 的工作流程可以概括为以下步骤：

1. 启动服务端进程并注册天气工具与模板；
2. 等待客户端发起工具调用请求；
3. 根据请求参数访问 OpenWeatherMap API；
4. 获取并格式化天气数据；
5. 将结果返回客户端，或与模板绑定生成结构化报告；
6. 客户端或模型据此生成自然语言回答。

这一流程体现了 MCP 框架的核心思想：通过标准协议将外部工具与大语言模型的能力无缝衔接，使模型能够自动化调用、理解与利用真实世界数据。

------

### 五、系统特性与扩展建议

  该服务器端具备结构清晰、模块独立、通信标准化的特点。
 借助异步 HTTP 调用，它在处理多并发天气请求时性能优越；通过模板机制，它能让模型生成一致性强、自然流畅的播报内容。

未来可以在以下方向进一步扩展与优化：

- **增加缓存机制**：对常用城市的查询结果进行短期缓存，减少 API 调用频率；
- **支持经纬度查询**：允许通过坐标而非城市名直接获取天气信息；
- **增强错误处理**：区分网络错误、API 错误和数据解析错误，提高系统健壮性；
- **多语言支持**：根据 `lang` 参数自动返回对应语言版本；
- **模块化扩展**：可加入空气质量指数（AQI）、紫外线指数等更多工具函数。

------

----

## MCP_CLIENT实现说明文档

### 一、项目概述

本项目实现了一个基于 **MCP（Model Context Protocol）** 框架的智能体客户端，能够与 MCP 服务端进行通信，并使用 **DeepSeek V3 大语言模型** 实现自然语言驱动的自动工具调用与响应生成。

简单来说，这个客户端充当了一个“智能中间人”：

- 一方面，它通过 **MCP 协议** 与后端工具（如天气查询、数据库操作等）通信；
- 另一方面，它通过 **DeepSeek API** 与大模型交互；
- 当用户输入自然语言问题时，模型会自动决定是否调用 MCP 工具，并根据工具返回的结果生成最终回答。

------

#### 二、系统结构设计

整个系统分为以下几个核心模块：

| 模块名称                   | 主要功能                                                  |
| -------------------------- | --------------------------------------------------------- |
| **DeepSeekMCPClient**      | 客户端核心类，负责与 MCP 服务连接、调用工具、与模型通信。 |
| **MCP Server（外部服务）** | 提供可调用的工具函数，如天气查询、计算器等。              |
| **DeepSeek API**           | 负责理解用户请求，决定是否使用工具，并生成自然语言回答。  |
| **AsyncExitStack**         | 异步资源管理器，用于在程序结束时自动关闭连接、释放资源。  |

系统运行结构如下：

<center>用户输入问题<center>
     ↓
<center>DeepSeek MCP Client<center>
                  ↓       


<center>DeepSeek V3 模型<center>
     ↓


<center>MCP 工具服务器 (Python/JS)<center>
     ↓
<center>DeepSeek 模型生成最终回答<center>
     ↓


<center>输出给用户<center>


------

### 三、主要功能流程

#### 1. 程序启动与参数解析

在 `main()` 函数中，程序首先解析命令行参数，要求输入 MCP 服务端脚本路径（`.py` 或 `.js` 文件）。
 若参数不足，会输出提示信息并退出。

```bash
python client.py <服务器脚本路径>
```

#### 2.创建并初始化客户端

 `def_init_()` 函数负责创建一个`DeepSeekMCPClient()` 类的客户端，并进行初始化，从环境变量中读取KEY和URL。

#### 3. 与 MCP 服务器建立连接

`connect_to_server()` 函数负责与 MCP 服务端建立通信连接：

- 根据文件后缀判断使用 `python` 或 `node` 选择启动命令；
- 通过`StdioServerParameters()`设置MCP服务器参数； 
- 通过 `stdio_client()` 创建标准输入输出通信信道（stdin/stdout方式）；
- 使用 `ClientSession` 建立MCP客户端会话；
- 初始化连接并列出服务端提供的工具列表。

eg：

```
已连接到MCP服务，可用的工具列表: ['get_weather', 'get_location']
```

#### 4. 处理用户请求

主循环函数 `chat_loop()` 提供简单的命令行交互界面：

- 用户输入问题；
- 程序调用 `process_query()` 处理；
- 输出模型回答或工具的响应；
- 输入 `quit` 退出程序。

#### 5. 调用模型处理请求

`process_query()` 是系统的核心函数。

- 构造包含系统提示和用户输入的 `messages` 列表；
- 向 MCP 服务端请求可用工具；
- 将MCP工具信息转换为模型可理解的格式；
- 调用 DeepSeek API，传入问题和可用工具；
- 解析模型的回复，判断是否需要调用工具。

#### 6. 工具调用与结果处理

若模型请求调用工具：

- 解析工具名称与参数；
- 调用 `session.call_tool()` 执行工具；
- 获取工具执行结果并打印；
- 将结果加入到对话历史；
- 检查工具是否返回模板（Prompt Template）；
- 如有模板，调用 `session.get_prompt()` 生成提示；
- 再次请求模型，根据工具结果生成最终回答。

如果模型未调用工具，则直接输出模型回复内容。

#### 7. 资源清理

当程序结束时（无论正常退出还是异常中断），`cleanup()` 函数会自动关闭会话和通信通道，释放资源。

----

---

## 前端用户界面实现说明文档

### 一、概述

本项目开源文件中的前端界面是一个基于 **现代 Web 技术栈** 的用户交互层，作为天气出行助手的可视化呈现平台，用于接收用户输入并展示智能体生成的出行建议。

简单来说，这个前端界面扮演了一个"用户友好门户"的角色：

- 一方面，它通过 **多模态输入方式**（文字、语音、文件、快捷模板）收集用户出行需求；
- 另一方面，它通过 **美观的界面设计** 将 MCP 客户端返回的天气数据转化为直观的出行建议；
- 当用户与界面交互时，前端会处理输入、调用 MCP 客户端接口、格式化展示结果并提供流畅的对话体验。

通过该前端界面，用户能够轻松获取天气信息、查看出行建议，并享受自然流畅的智能助手服务。

### 二、应用结构设计

#### 2.1 系统架构

整个前端设计分为以下几个板块：

| 层级           | 功能模块                           | 主要职责             |
| -------------- | ---------------------------------- | -------------------- |
| **用户界面层** | 侧边栏导航，主聊天区域，输入控制区 | 界面布局和交互设计   |
| **业务逻辑层** | 对话管理，消息处理，语音识别       | 核心业务逻辑处理     |
| **数据层**     | 本地存储，状态管理                 | 数据持久化和状态维护 |
| **工具层**     | 文件处理，动画效果，JSON解析       | 辅助功能实现         |

#### 2.2 核心功能模块

##### 2.2.1 JSON数据预处理

```javascript
// 去除前缀JSON对象的工具函数
function stripLeadingJsonBlocks(input) {
  // 专门处理MCP客户端返回的JSON结构，提取纯文本内容
  // 支持连续多个JSON对象的清理，确保显示纯净的文本回复
}
```

##### 2.2.2 视觉系统配置

```javascript
tailwind.config = {
  theme: {
    extend: {
      colors: {
        primary: '#09AF73',    // 品牌主色 - 青绿色
        secondary: '#078A5B',  // 辅助色
        neutral: '#F5F7FA',    // 中性背景
        dark: '#1D2129',       // 深色文字
      },
      fontFamily: {
        inter: ['Inter', 'system-ui', 'sans-serif'], // 现代字体
      },
    },
  }
}
```

#### 2.3 系统运行流程

```
用户输入问题 → 信息处理 → Web API调用 → MCP客户端处理 → 响应解析 → 界面更新
    ↓
文字/语音/文件 → 统一格式化 → HTTP请求 → 工具调用 → JSON清理 → LocalStorage
```

前端设计过程中，首先确定了页面的主色调和用户界面，明确实现该功能所需组件，合理设计出各个组件的位置和图案大小，同时添加了新模块来介绍该网页的功能，对用户界面侧边栏滑入滑出、界面中央图案弹跳、语音输入时按钮变化、滚动条变化都进行了动画设计。界面设计时，通过不断调试确保网页各个部分（侧边栏、聊天区、顶部栏）正确摆放，互不遮挡，比如历史记录按钮、头像、名字三部分进行并排处理，确定合适的距离。为了丰富智能体功能，给用户界面添加了语音识别、文件识别等功能。同时，对电脑端和手机端网页进行了部分区别处理。

### 三、主要功能流程

#### 3.1 应用初始化与界面构建

在页面加载时，通过以下代码初始化前端应用：

```javascript
document.addEventListener('DOMContentLoaded', () => {
  initVoiceRecognition();
  initChatData();
  adjustTextareaHeight();
  window.dispatchEvent(new Event('resize'));
});
```

`DOMContentLoaded` 事件确保在DOM完全加载后执行初始化。所有界面组件和事件监听器都将在此阶段注册完成。

#### 3.2 数据通信与处理

##### 3.2.1 Web服务器通信

前端通过HTTP API与后端Web服务器通信：

```javascript
async function sendMessageToServer(message) {
  try {
    const response = await fetch('/api/chat', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ message })
    });
    
    const data = await response.json();
    if (data.success) {
      // 清理JSON结构，提取纯文本
      const cleanText = stripLeadingJsonBlocks(data.reply);
      return cleanText;
    } else {
      throw new Error(data.error);
    }
  } catch (error) {
    console.error('API请求失败:', error);
    return '❌ 网络请求失败，请检查服务器连接';
  }
}
```

##### 3.2.2 JSON响应处理

专门处理MCP客户端返回的复杂JSON结构：

```javascript
// 处理可能的JSON前缀，如：
// {"content": "文本内容"} 或连续多个JSON对象
// 提取出纯净的文本内容用于界面显示
```

#### 3.3 多模态输入处理逻辑

用户输入支持四种方式，前端负责统一处理和格式化：

- **文本输入**：通过智能 `textarea` 元素接收，支持自适应高度调整
- **语音输入**：集成 Web Speech API，实现实时语音转文字功能
- **文件上传**：支持图片和文档文件，提供预览和大小验证（≤5MB）
- **快捷模板**：预设常用出行问题，一键填充输入框

#### 3.4 对话状态管理与数据持久化

本项目定义了完整的对话管理机制：

- **`createNewChat()`**：创建新对话会话，重置界面状态；
- **`loadChat(chatId)`**：加载指定对话历史，恢复消息记录；
- **`saveChatData()`**：将对话数据保存到本地存储；
- **`deleteChat(chatId)`**：删除指定对话，包括标题和消息记录。

这些函数通过操作 `chatTitles` 和 `chatMessages` 两个核心数据对象，维护对话的完整生命周期。

#### 3.5 消息渲染与界面更新

函数 `addMessage(content, isUser, skipSave)` 负责将消息内容转换为可视化的聊天气泡：

- 用户消息右对齐，绿色背景（`#09AF73`）
- 助手消息左对齐，灰色背景（`#EFEFEF`）
- 自动滚动到底部，确保最新消息可见
- 支持消息复制功能

#### 3.6 响应式布局与交互机制

- **桌面端**（≥1024px）：固定侧边栏布局，主内容添加内边距
- **移动端**：侧滑导航设计，触摸友好的交互
- **自适应**：输入框高度自动调整，动画效果适配

### 四、与Web服务器的集成测试

#### 4.1 本地开发环境部署

##### 环境配置

```bash
# 1. 安装Python依赖
pip install fastapi uvicorn httpx

# 2. 设置环境变量
export API_KEY="your_deepseek_api_key"
export BASE_URL="https://api.deepseek.com"
export MODEL="deepseek-chat"

# 3. 启动Web服务器
python web_server.py
```

##### 项目结构验证

确保以下文件结构：

```
project/
├── web_server.py          # FastAPI Web服务器
├── web/
│   └── index.html         # 前端界面
├── weather/
│   └── weather.py         # MCP天气服务
└── mcp-client/
    └── client.py          # MCP客户端
```

#### 4.2 接口测试流程

##### 健康检查

```bash
curl http://localhost:8000/api/health
# 期望响应: {"status":"healthy","mcp_client_ready":true}
```

##### 功能测试

```javascript
// 前端调用示例
const testMessage = async () => {
  const response = await fetch('/api/chat', {
    method: 'POST',
    headers: {'Content-Type': 'application/json'},
    body: JSON.stringify({message: '北京天气怎么样？'})
  });
  const data = await response.json();
  console.log('服务器响应:', data);
};
```

#### 4.3 数据处理验证

测试JSON清理功能：

```javascript
// 测试数据
const testData = [
  '{"content": "今天天气晴朗"}',
  '{"result": "适合出行"}\n{"data": "温度25度"}',
  '纯净的文本消息'
];

testData.forEach(input => {
  const cleaned = stripLeadingJsonBlocks(input);
  console.log('清理前:', input);
  console.log('清理后:', cleaned);
});
```

### 五、运行流程总结

WeaTrip 前端界面的完整工作流程可以概括为以下步骤：

1. **用户访问应用**，初始化界面组件、事件监听系统和语音识别功能；
2. **用户通过多模态方式**输入天气出行相关问题（文字、语音、文件或快捷模板）；
3. **前端处理用户输入**，通过Web API调用后端服务器；
4. **Web服务器接收请求**，通过MCP客户端调用相应的工具函数；
5. **MCP服务端处理请求**，访问天气数据源并返回结构化结果；
6. **前端接收响应**，使用`stripLeadingJsonBlocks`清理JSON结构，提取纯净文本；
7. **界面更新展示**，以美观的聊天气泡形式显示结果；
8. **自动保存对话记录**，维护完整的聊天历史。

这一流程体现了现代Web应用的核心思想：通过直观的界面设计和智能的数据处理，将复杂的AI服务封装为简单易用的聊天体验。

### 六、系统特性与扩展建议

#### 6.1 系统特性

该前端界面具备以下突出特点：

- **🎨 交互友好**：仿聊天应用的直观界面，零学习成本
- **🔧 多模态输入**：支持文字、语音、文件等多种输入方式
- **📱 响应式设计**：完美适配桌面端和移动端设备
- **💾 数据持久化**：完整的本地对话历史管理
- **🔄 实时通信**：与Web服务器的稳定API通信
- **🎯 智能处理**：专业的JSON数据清理和格式化

#### 6.2 扩展建议

未来可以在以下方向进一步扩展与优化：

- **🔍 增强搜索功能**：实现对话内容的全文搜索和高亮显示
- **📊 数据分析**：添加用户行为分析和常用查询统计
- **🔔 实时通知**：支持天气预警和重要通知的推送功能
- **🌍 多语言支持**：根据用户偏好显示不同语言的界面
- **⚡ 性能优化**：实现消息虚拟滚动，优化大量历史记录的渲染性能
- **🎨 主题定制**：支持深色模式和多主题切换
- **📱 PWA支持**：将应用转换为渐进式Web应用，支持离线使用
- **🔗 社交集成**：支持将出行建议分享到社交媒体平台

---

